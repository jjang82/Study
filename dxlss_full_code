# 학습 안내(교육생용)

# 시작하기에 앞서 ----------------------------------------------------------------

# dir.create("D:/#.Secure Work Folder/DX-LSS-Project/DX-LSS강사과정")
setwd("D:/#.Secure Work Folder/DX-LSS-Project/DX-LSS강사과정")
getwd()


# Define ------------------------------------------------------------------

x=2
y=2
x+y

sin(30)
sin(30*(pi/180))
pi/180

A = c(1,2,3,4,5)        
A[2]

A1 = 1:9
A1

dim(A1) <- c(3,3)
A1

A2 = matrix(nrow=3, ncol=3, 1:9) #학습내용엔 없음
A2


A=seq(1,10)
A
sum(A)
?seq

A=rep(1,10)
A
B=seq(1,10)
B
sample(B,3)

#아래는 보충 설명 내용

#내장된 mtcats 데이터를 통해 확인해봄)
is.data.frame(mtcars)
mean(mtcars$mpg)



# QUIZ1
# mtcars의 mpg(miles per gallon)열의 합계를 구해보세요
mean(mtcars[,1])
a=mtcars[,1]
a

# QUIZ2
#mtcars의 데이터에서 dart와 wt열의 데이터의 평균과 합계를 구해보세요

mtcars[,5:6]
sum(mtcars[,5])
sum(mtcars[,6])
sum(mtcars[,5:6])

mtcars[, 'mpg']
colnames(mtcars)
rownames(mtcars)
str(mtcars)

head(mtcars)

# measure -----------------------------------------------------------------

library(dplyr)

mtcars %>% head(., n=5) %>% dim(.)

dim(head(mtcars, n=5))

mtcars %>%  slice(., 1:5)    #결과창이 차이가 있음, 아래 있는 내용으로 반영되어 있음

mtcars %>%  filter(., cyl>6, mpg>16)

mtcars %>%  select(., mpg,cyl,disp,gear)

mtcars %>%  select(hp,cyl,qsec) %>%  mutate(hp_per_cyl=hp/cyl)

# mtcars %>%  mutate(hp_per_cyl=hp/cyl)  # select없이 단독으로 사용 가능함

mtcars %>%  group_by(., cyl,gear) %>% summarise(mpg=mean(mpg))

mtcars


install.packages("tidyr")
library(tidyr);library(dplyr)

mtcars

rownames(mtcars)

mtcars$name=rownames(mtcars);rownames(mtcars)=NULL

mtcars$name

mtcars01 = mtcars %>%  select(name,mpg,cyl,disp)

mtcars01

mtcars01 %>%  gather(key="key", value="value", mpg, cyl, disp)

mtcars02 = mtcars01 %>%  gather(key ="key", value="value",mpg,cyl,disp)

mtcars02

mtcars02 %>%  spread(key,value)


mtcars1 = mtcars[,c(1:7,12)]
mtcars2 = mtcars[,8:12]

mtcars1
mtcars2

left_join(mtcars1, mtcars2, by="name")  # s가 빠짐, merge를 위해서 조정 필요. 

mtcar1 = mtcars[,c(1:7,12)]
mtcar2 = mtcars[,8:12]

merge(mtcar1, mtcar2, by="name")


mtcars1 = mtcars[,c(1:7,12)]
mtcars2 = mtcars[,8:12]

cbind(mtcars1,mtcars2)     # s가 빠짐


Sys.Date()
Sys.time()

x=Sys.time()
x
x2=format(x,"%Y-%m-%d")


as.POSIXct(x2)-as.POSIXct(x3)     # x3 정의가 없음.


iris
scale(iris[,1:4])
na.omit(iris[,1:4])


# 사례연구 설명- 제미매트
# apply 추가 설명  



# 2일차 교육 시작 ---------------------------------------------------------------

#1일차 복습 

2+3
cos(0)
sin(0)
x=3
y=2
x*y

x=30
x
x=c(3,30)
x*y
x=c(1,2,3,4,5,6,7,8,9,10)
x
x=c(1:10)
x
seq(1,1000)
seq(1,1000,0.5)
x=seq(1,100)
x
seq(1,100)
1:100
5:100

x=seq(1,100,0.4)
x[197]

rep(2,100)
rep(c(1,2),100)
rep(c(1,2),each=100)
rep("kim",100)

sample(1:100,10)
help(sample)

# vector, matrix, data.frame

x=c(1,2,3,4,5,6,7,8,9,10)

matrix(x, 5, 2)
matrix(x, 5) #하나만 적어도 상관없음
matrix(x, nrow=5, ncol=2) #실제 명령


data.frame() #개념 설명 후 실습
mtcars
mtcars[,c(1,2)]
head(mtcars)
mtcars$mpg
mtcars$mpg[mtcars$mpg>20.1]


library(tidyr);library(dplyr)
mtcars %>% head(2) # %>%는 그리고의 의미 
mtcars %>%  dim()

mtcars %>% select(mpg,cyl)
mtcars %>% filter(mpg>20.1)
mtcars %>% slice(2:6)

#left_join, merge, Sys.time, Sys.Date,
#as.PoSIXct(), group_by, gather, spread()



# Analyze -----------------------------------------------------------------

x=c(3,4,4,6,4,7,9,10,11,11);y=c(11,13,12,19,13,22,28,32,36,32)
plot(y~x)
A=lm(x~y)
summary(A)
abline(A, col="red")

predict(A)
y

rbind(y,predict(A))
plot(A)

par(mfrow=c(2,2))
plot(A)



A=iris
library(tree)
B=tree(Species~Sepal.Length+Sepal.Width+Petal.Length+Petal.Width,data=A)
plot(B);text(B)      # , 에서 ; 으로 수정
predict(B, type="class")

#보충설명
library(tidyr) ; library(dplyr)
library(tree)
iris %>% head()

tree(Species~.,data=iris)



library(MASS)
library(randomForest)
data(cpus)
RF.2=randomForest(log10(perf)~syct+mmin+mmax+cach+chmin+chmax,data=cpus, importance=TRUE)
RF.2
varImpPlot(RF.2)
predict(RF.2, data=cpus)


reg.fit=lm(log10(perf)~syct+mmin+mmax+cach+chmin+chmax, data=cpus)
summary(reg.fit)
step(reg.fit)


library(car)
reg.fit2 = lm(log10(perf)~syct+mmin+mmax+cach, data=cpus)
vif(reg.fit2)
plot(reg.fit2)



pr.out=prcomp(USArrests, scale=T)
summary(pr.out)
pr.out$rotation ; biplot(pr.out, scale=0)

library(pls)
library(ISLR)  #Hitters 자료가 ISLR에 있음
Hitters
pcr.fit=pcr(Salary~.,data=Hitters, scale=T)
pcr.fit;summary(pcr.fit)
pcr.pred=predict(pcr.fit, data=Hitters,ncomp=7)
pcr.pred


library(pls)
pls.fit=plsr(Salary~., data=Hitters, scale=T)
summary(pls.fit)
pcr.pred=predict(pcr.fit, data=Hitters, ncomp=2)
pcr.pred



H1=na.omit(Hitters)  #na.omit해야 돌아감 맞나요?
x=model.matrix(Salary~., H1)[,-1]  
y=H1$Salary


library(glmnet)
grid=10^seq(10,-2,length=100)
ridge.mod=glmnet(x,y,alpha=0, lambda=grid)
summary(ridge.mod)

cv.out=cv.glmnet(x,y,alpha=0)
plot(cv.out)
bestlam=cv.out$lambda.min
ridge.pred=predict(ridge.mod, s=bestlam,x)
ridge.pred


library(MASS) ; library(tree)
tree.boston=tree(medv~., data=Boston)
plot(tree.boston);text(tree.boston)


library(ipred)
bag.fit=bagging(medv~., data=Boston, nbagg=25)
summary(bag.fit)
predict(bag.fit, data=Boston)

library(randomForest)
rf=randomForest(medv~., data=Boston, mtry=6)
summary(rf)
predict(rf, data=Boston)

library(DescTools)
y_obs = Boston$medv
y_bag = predict(bag.fit, data=Boston)
y_rf = predict(rf, data=Boston)

# MSE(y_obs, y_bag)
# MSE(y_obs, y_rf)


library(ISLR) ; library(MASS)
lda.fit=lda(Direction~Lag1+Lag2, data=Smarket)
lda.fit


library(ISLR)
glm.ift=glm(Direction~Lag1+Lag2, data=Smarket, family="binomial")

library(e1071)
svmfit=svm(Direction~Lag1 + Lag2, data=Smarket, kernel="linear", cost=10, scale=F)
plot(svmfit, data=Smarket[,c(2,3,9)])      # ) 빠짐


#install.packages("neuralnet")
library(neuralnet)
m1 = scale(mtcars)
neu = neuralnet(mpg~., data=m1, hidden = c(4,4))
plot(neu)
compute(neu,m1)$net.result



# improve -----------------------------------------------------------------

x=c(3, 4, 4, 6, 4, 7,  9, 10, 11, 11); y=c(11, 13, 12, 19, 13, 22, 28, 32, 36, 32)
A=lm (y~x);  predict(A)
library(DescTools)
MSE(y, predict(A))
RMSE(y, predict(A))


B =tree(Species ~ Sepal.Length + Sepal.Width + Petal.Length + Petal.Width, data=iris)
D = predict(B , type="class")
library(caret)
confusionMatrix(D , iris$Species)

library(ROCR)
y_obs = ifelse("versicolor" == iris$Species,1,0)
D = ifelse("versicolor" == predict(B, type="class"),1,0)
pred = prediction(D , y_obs)
plot(performance(pred, "tpr", "fpr"))


temp = data.frame(x,y)
A=lm(y~x, data=temp)

temp1 = temp[1,]
temp1[1,"x"] <- 5
predict(A, newdata = temp1)


# 학습안내 _ 강사용

# DX-LSS BB과정 --------------------------------------------------------------
# 작성자 : 백인엽P,  최종 수정일 : 20. 7. 20
# Text encoding : UTF-8

# 0. 들어가기 앞서 -----------------------------------------------------------

# R Studio 화면 설명

# 유용한 단축키

# 여기 ----------------------------------------------------------------------


# Ctrl + Shift + O   # Script 목차보기(Code > Show Document Outline, 아이콘)

# Ctrl + Shift + R   # Script 목차를 넣기(Code > Insert Section)

# Ctrl + Shift + N   # R Script 새로만들기(File > New File > R script)

# Ctrl + Shift + M   # %>% 연산자 

# Ctrl + shift + F10 # R 재구동(Session > R restart)

# Ctrl + S           # Script 저장하기 (File > Save)


# ***세부 환경 설정 ------------------------------------------------------------

# 깨끗한 환경 시작하기
# Ctrl + L        # 단축키 : Console창 삭제
# ctrl + Enter or  Alt + Enter  # Script 명령 실행

ls()              # 등록된 모든 변수 list를 표시해줘
rm()              # 등록된 변수를 제거해줘
list = ls()       # 등록된 변수를 list에 모두 담아줘

rm(list = ls())   # 등록된 모든 변수 제거(빗자루 아이콘으로 가능)
dev.off()         # Plots 이미지 모두 삭제(빗자루 아이콘으로 가능)

#set Working directory 
getwd()
setwd("D:/#.Secure Work Folder/DX-LSS-Project/BB/DAT")
dir()


# 1일차 교육 시작 ---------------------------------------------------
# R-프로그래밍 소개 -------------------------------------------------

# ● 계산기로써의 R --------
3+2
3-2
3*2
3/2

3^2
log(10)
log10(10)
sin(0)
sin(90*pi/180)

# 변수입력
x
x = 2
y = "LG"

x = 3
y = 5
x + y



# ● c함수, [ ]함수 ---------------------------------
# 벡터
A = c(1,5,3,4,5)  #combine
A[2]


# 행렬 
A = matrix(c(1:9), nrow = 3, ncol = 3)
A
A[2,2]
is.matrix(A)

x = c(1,2,3,4,5)
y = c(2,4,6,8,10)
data.frame(x,y)

A = data.frame(x,y)
A[3,2]

# seq, sum 함수
A = seq(1,10)
A
sum(A)
1:10

# rep, sample함수
A = rep(1,10)
A

# set.seed(123)
B = seq(1,10)
B
sample(B,3)


data(mtcars)
is.data.frame(mtcars)
dim(mtcars)
head(mtcars)

mtcars[,1]
mtcars[,'mpg']
mtcars[,5:6]
str(mtcars)
mtcars$mpg

# I. measure ---------------------------------------------------------------

# 전처리 Preprocessing ----------------------------------------------------------

# ● 파이프 연산자 ----------------------------------------------------------
# install.packages("dplyr")  #다양한 패키지를 선택하여 설치하는 함수
library(dplyr)               # 설치된 패키지를 사용하기 위해 부착하는 함수 
data(mtcars)

head(mtcars, n=3)

dim(head(mtcars, n=5)) # 복잡

mtcars %>% head(., n=5) %>% dim(.)
mtcars %>% head(., n=5) %>% dim()
mtcars %>% head(, n=5) %>% dim()
mtcars %>% head(,5) %>% dim()
mtcars %>% head(.,5) %>% dim()
mtcars %>% head(5) %>% dim()

# fun(x,y,z) 는  x %>% fun(y,z)
# y %>% fun(x, ., z)
# fun3(fun2(fun1(x))) = x %>%  fun1 %>%  fun2 %>% fun3

# ● Slice ----------------------------------------------------------
slice(mtcars,1:5)
mtcars %>%  slice(.,1:5)   
mtcars[행,열]
mtcars[1:5,]
mtcars[1:5,1]
mtcars[1:5,-1]
mtcars[1:5,2:11]
mtcars[1:5,c(2:11)]
mtcars[1:5,c(2,5:11)]
mtcars[1:5,-c(1,3)]
mtcars[3,-c(1,3)]

# ● filter --------------------------------------------------------
mtcars %>%  filter(., cyl>6, mpg>16)
mtcars %>%  filter(., cyl>6 & mpg>16)
mtcars %>%  filter(., cyl>8 | mpg>18)
mtcars %>%  filter(., cyl==6, mpg>18)
mtcars %>%  filter(., cyl!=6, mpg>18)
mtcars %>%  filter(., cyl!=6, mpg>18 , gear == 4)


# ● select ----------------------------------------------------------
colnames(mtcars)
select(mtcars, mpg,cyl,disp,gear)
mtcars %>%  select(., mpg,cyl,disp,gear)
mtcars %>%  select(, mpg,cyl,disp,gear)
mtcars %>%  select(mpg,cyl,disp,gear)
mtcars %>%  select(-mpg)
mtcars[행,열]
mtcars[,-1]

# ● mutate ----------------------------------------------------------
mtcars %>% select(hp,cyl,qsec) %>% mutate(hpp=hp/cyl)

x = c(1,2,3,4,5)
y = c(2,4,5,7,8)
data.frame(x,y)
D = data.frame(x,y)
D %>% mutate(xy = x*y)
D
E = D %>% mutate(xy = x*y)
E

# ● group_by, summarise ---------------------------------------------
mtcars %>% group_by(., cyl, gear) %>% summarise(mpg=mean(mpg))

mtcars %>% group_by(., cyl, gear) %>% summarise(mpg=sd(mpg))
mtcars %>% group_by(., cyl, gear) %>% summarise(mpg=IQR(mpg)) 
mtcars %>% group_by(., cyl, gear) %>% summarise(mpg=max(mpg))
mtcars %>% group_by(., cyl, gear) %>% summarise(mpg=min(mpg))


# summarize 도 동일


# ● 세로형 / 가로형 데이터 변환 -------------------------------------
#install.packages("tidyr")
library(tidyr);library(dplyr)

rownames(mtcars)

mtcars

mtcars$name=rownames(mtcars) ; rownames(mtcars)=NULL

mtcars01 = mtcars %>%  select(name,mpg,cyl,disp)
mtcars01

mtcars01 %>%  gather(key="key", value="value", mpg, cyl, disp)

mtcars02 = mtcars01 %>%  gather(key ="key", value="value",mpg,cyl,disp)
mtcars02

mtcars02 %>%  spread(key,value)
D = mtcars02 %>%  spread(key,value)

# ● Left_join --------------------------------------------------

mtcars
mtcars1 = mtcars[,c(1:7,12)]
mtcars2 = mtcars[,8:12]

head(mtcars1)
head(mtcars2)

left_join(mtcars2, mtcars1, by="name") 
left_join(mtcars1, mtcars2, by="name")   



# ● merge --------------------------------------------------
mtcar1 = mtcars[,c(1:7,12)]
mtcar2 = mtcars[,8:12]
head(mtcar1)
head(mtcar2)

merge(mtcar1, mtcar2, by="name")
# merge(mtcars2, mtcars1, by="name")


# 부연설명
library(dplyr)
rm(list=ls())
A1 = data.frame(name=c("한국","미국","중국","일본"), 
                population=c(0.51,3.3,14,1.25)) 

A2 = data.frame(name=c("한국","미국","일본","북한", "인도","브라질"), 
                rank=c(28,3,11,52,2,5)) 

inner_join(A1,A2,by='name')
merge(A1,A2,by='name')  #inner join과 같음
full_join(A1,A2,by='name')
merge(A1,A2,by='name',all=TRUE) # full join과 같음 
left_join(A1,A2,by='name')
merge(A1,A2,by='name',all.x=TRUE) # left join과 같음 
right_join(A1,A2,by='name')
merge(A1,A2,by='name',all.y=TRUE) # right join과 같음


# ● bind  --------------------------------------------------
# mtcars$name=rownames(mtcars) ; rownames(mtcars)=NULL
mtcars
mtcars1 = mtcars[,c(1:7,12)]
mtcars2 = mtcars[,8:12]

cbind(mtcars1,mtcars2)   

#mtcars12 = cbind(mtcars1,mtcars2)   

A1 = mtcars[1:10,]
A2 = mtcars[11:20,]
A3 = mtcars[21:32,]

head(A1); head(A2); head(A3)

rbind(A1,A2)
rbind(A1,A2,A3)


# ● Data import ----------------------------------------------------------
library(readxl)
dir()
getwd()
read_excel("dataset.xlsx")
read_excel("dataset.xlsx", sheet ="no3")
read_excel("dataset.xlsx", sheet ="no1", range = "B2:E12")
read_excel("dataset.xlsx", sheet ="no1", range = "H2:L12")
read.csv("bpa_set_1.csv")


# ● 날짜 기준 변경  ----------------------------------------------------------
Sys.Date () 
Sys.time () 

# 날짜 형식
x=Sys.time()
x
x2=format(x, "%Y-%m-%d")
x2
x3=format(x, "%1947-%01-%05")
x3

str(x2)
str(x3)
x2-x3

# 날짜 시간 계산
as.POSIXct(x2)
as.POSIXct(x2)-as.POSIXct(x3)     

difftime(x2,x3, units = c("hours") )
# units = c("auto", "secs", "mins", "hours","days", "weeks")



# ● 표준화  ----------------------------------------------------------
iris
str(iris)
scale(iris[,1:4])


# 결측치 제거 
na.omit(iris[,1:4])



# apply 추가 자료 : 별도 설명 과정 없음
rm(list=ls())
apply(mtcars, 1, mean) #행 평균
apply(mtcars, 2, mean) #열 평균
apply(mtcars[1:3], 1, mean) # 1:3열 데이터의 행평균
apply(mtcars[1:3], 2, mean) # 1:3열 데이터의 열평균
colnames(mtcars)

mtcars
apply(mtcars[2:3],1,sum) # 2:3열 데이터의 행 합계
apply(mtcars[4:5],1,sum) # 4:5열 데이터의 행 합계


data.frame(y=mtcars[,1], 
           cyl_disp = apply(mtcars[2:3], 1, sum), 
           ht_drat = apply(mtcars[4:5],1,sum))








# QUIZ  ---------------------

Q3 = read_excel("dataset.xlsx", sheet="no3")
str(Q3)
Q3$time   #해당 열의 이름의 형식을 변경
# 0000 = format(0000, "%Y-%m-%d")


















# QUIZ 1 ----------------------------
A = data.frame(volt = c(2, 4, 6, 8, 10), type = c("A", "B", "A", "B", "A"))
B = data.frame(volt = c(2, 4, 6, 8, 10), current = c(4, 10, 5, 10, 5))

#정답 : Q1
# 1)
AB = merge(A, B, key = "volt")
AB
# 2)
AB = mutate(AB, power = volt*current)
AB


# QUIZ 2 ----------------------------
rm(list=ls())
dir()
A1 = read_excel("dataset.xlsx", sheet="no1", range = "B2:E12")
A2 = read_excel("dataset.xlsx", sheet="no1", range = "H2:L12")

A12 = merge(A1,A2, key = "product")
na.omit(A12)


# QUIZ 3 ----------------------------
dir()
A3 = read_excel("dataset.xlsx", sheet="no3")
A4 = read_excel("dataset.xlsx", sheet="no4")

A3$time = format(A3$time, "%Y-%m-%d")
A4$time = format(A4$time, "%Y-%m-%d")

A34 = merge(A4, A3, key=time)
dim(A34)

A34$time = as.POSIXct(A34$time)

#library(ggplot2)
#ggplot(data=A34, aes(time,x1))+geom_point(alpha=0.2, color=9.5)
#ggplot(data=A34, aes(time,x2))+geom_point(alpha=0.2, color=9.5)
#ggplot(data=A34, aes(time,x3))+geom_point(alpha=0.2, color=9.5)
#ggplot(data=A34, aes(time,x4))+geom_point(alpha=0.2, color=9.5)

#pairs(A34)
#pairs(A34[,-1])


# 2일차 교육 시작 ---------------------------------------------------------------
# II Analyze -----------------------------------------------------------------

# ● 선형회귀 분석  ----------------------------------------------------------
#rm(list=ls())
#dev.off()
x=c(3,4,4,6,4,7,9,10,11,11); y=c(11,13,12,19,13,22,28,32,36,32)

plot(y~x) ; A=lm(y~x)
predict(A)
y
summary(A) ; plot(A)

opar = par(mfrow=c(2,2))

par(opar)

dev.off()

# ● 의사결정나무  ----------------------------------------------------------
A=iris
library(tree)
B=tree(Species~Sepal.Length+Sepal.Width+Petal.Length+Petal.Width,data=A)
B=tree(Species~.,data=A)

plot(B);text(B)     
predict(B, type="class")
iris$Species

library(rpart)
B = rpart(Species~.,data=A)
library(party)
B = ctree(Species~.,data=A)


# ● 랜덤포레스트  ----------------------------------------------------------
#rm(list=ls())
library(MASS)
library(randomForest)
data(cpus)
RF.2=randomForest(log10(perf)~syct+mmin+mmax+cach+chmin+chmax,data=cpus, importance=TRUE)
RF.2
varImpPlot(RF.2)
predict(RF.2, data=cpus)
log10(cpus$perf)

pairs(cpus)
summary(cpus)


# ● 다중회귀분석  ----------------------------------------------------------
reg.fit=lm(log10(perf)~syct+mmin+mmax+cach+chmin+chmax, data=cpus)
summary(reg.fit)
step(reg.fit)


# ● 분산팽창지수  ----------------------------------------------------------
library(car)
reg.fit2 = lm(log10(perf)~syct+mmin+mmax+cach, data=cpus)
vif(reg.fit2)
plot(reg.fit2)


lm.best = lm(perf~syct+mmin+mmax+cach, data=cpus)
predict(lm.best)
head(cpus)
cpus$perf
MSE(predict(lm.best), cpus$perf)
RMSE(predict(lm.best), cpus$perf)

# III improve -----------------------------------------------------------------

# ● MSE, RMSE ----------------------------------------------------------
rm(list=ls())
x=c(3, 4, 4, 6, 4, 7,  9, 10, 11, 11); y=c(11, 13, 12, 19, 13, 22, 28, 32, 36, 32)
A=lm (y~x);  predict(A)

library(DescTools)
MSE(predict(A), y)
RMSE(predict(A), y)


# ● confusionMatrix ----------------------------------------------------------
#rm(list=ls())
#dev.off()

library(tree)
B =tree(Species ~ Sepal.Length + Sepal.Width + Petal.Length + Petal.Width, data=iris)

D = predict(B , type="class")
iris$Species
data(iris)

library(caret)
confusionMatrix(D, iris$Species)


# ● ROCR ----------------------------------------------------------
library(ROCR)
iris$Species
ifelse("versicolor" == iris$Species,1,0)
y_obs = ifelse("versicolor" == iris$Species,1,0)

predict(B, type="class")
ifelse("versicolor" == predict(B, type="class"),1,0)

D = ifelse("versicolor" == predict(B, type="class"),1,0)

pred = prediction(D,y_obs)

plot(performance(pred, "tpr", "fpr"))
# performance(pred,"auc")@y.values


# ● 예측결과 ----------------------------------------------------------
#rm(list=ls())
x=c(3,4,4,6,4,7,9,10,11,11)
y=c(11,13,12,19,13,22,28,32,36,32)

temp = data.frame(x,y)
A=lm(y~x, data=temp)

temp[1,]
temp1 = temp[1,]

temp1[1,"x"]
temp1[1,"x"] <- 5
temp1[1,"x"]
predict(A, newdata = temp1)


# 다른 방법 
data.frame(x=5)
temp2 = data.frame(x=5)
predict(A, newdata = temp2)

temp2 = data.frame(x=8)
predict(A, newdata = temp2)



# QUIZ Time ---------------------

















# QUIZ 4 ----------------------------
dir()
A5 = read.csv("bpa_set_1.csv")
head(A5)
pairs(A5)
summary(A5)



# QUIZ 5 ----------------------------
A6 = lm(D50~.,data=A5[,-1])
summary(A6)

step(A6)
A7 = lm(D50~x7+x1+x4+x3+x6+x2+x8, data = A5[,-1])
summary(A7)

library(car)
vif(A7)
A8 = lm(D50~x7+x1+x3+x6+x2+x8, data = A5[,-1])
step(A8)

A9 = lm(D50~x1+x7+x6+x2+x8, data = A5[,-1])
summary(A9)


# QUIZ 6 ----------------------------
library(randomForest)
A10 = randomForest(D50~.,data=A5[,-1], importance = TRUE)
A10
varImpPlot(A10)


# QUIZ 7 ----------------------------
library(DescTools)
y_obs = A5$D50
y_lm = predict(A9, data=A5[,-1])
y_rf = predict(A10, data=A5[,-1])

MSE(y_lm, y_obs)
MSE(y_rf, y_obs)

RMSE(y_lm, y_obs)
RMSE(y_rf, y_obs)

summary(A9)


df = data.frame(x1 = 15.3, #음
           x7 = 56.5, #양
           x6 = 32.5, #양
           x2 = 164, #음
           x8 = 1.3  #양
           )

predict(A9, newdata = df)


# 석_예제

# DX-LSS BB과정 ------------------------------------------------------------
# 작성자 : 백인엽P,  최종 수정일 : 20. 7. 22
# Text encoding : UTF-8

# 01. 세부 환경 설정 -----------------------------------------------------------

# set Working directory 

getwd()
setwd("D:/#.Secure Work Folder/DX-LSS-Project/BB/석유")
# R Studio에서 Session > Set working directory > choose directory 로 설정 가능

dir()

rm(list = ls())   # Data set 삭제(Global Environment)


# 02. 데이터 전처리 ------------------------------------------------------------

# 전처리 도구 불러오기
library(dplyr);library(tidyr)

# 데이터 불러오기 
dir()
pis_product = read.csv("pis_raw_제품2.csv")
lims=read.csv("LIMS.csv") 
bucket=read.csv("Bucket.csv")

# 데이터 체크
head(pis_product)
head(lims)
head(bucket)

str(pis_product)
str(lims)

# lims 데이터 중 필요한 데이터만 선택
colnames(lims)

lims1 = lims %>%  select(Date.Time, PSD..LT.0.15mm., PSD..LT.0.85mm., PSD..0.85.2.0mm.)
lims2 = lims[,c(1,22,24,25)]

head(lims1)
head(lims2)

head(lims)

# lims = lims[ , c(1,22,24,25)]
             
# lims 데이터 중 project Y만 선택 Date.Time, PSD..LT.0.15mm., PSD..LT.0.85mm., PSD..0.85.2.0mm.
head(lims) # 변수 선택 저장 결과 체크


# D50 계산식 추가
str(lims) # PSD.. 0.85. 2. 0mm가 Factor로 들어가있으니, numeric으로 변경

lims[,4]
lims[,4] = as.numeric(as.character(lims[,4])) 

lims$PSD..0.85.2.0mm. = as.numeric(as.character(lims$PSD..0.85.2.0mm.))  

# Factor는 반드시 character로 변환 후 numeric으로 변환시켜야 함.
# (아니면 다른 값이 됨)

str(lims) #변환 결과 체크 


# D50을 구하는 공식은 식은 내부에서 공식 활용
# D50 = 850 + ( 50 - 'PSD(LT 0.85mm)' ) / 'PSD(0.85~2.00)' X (2000-850)

lims=lims %>% mutate(D50=(850+(50-PSD..LT.0.85mm.)/PSD..0.85.2.0mm.*(2000-850))) 
lims
head(lims) # 변환 결과 확인



lims=lims[,c(1,2,5)] # 사용할 변수만 저장. select 명령을 사용해도 됨 
head(lims)
summary(lims)

# data 현수준 파악을 위한 데이터 저장이며, R에서 현수준 파악해도 됨
write.csv(lims, 'lims_D50.csv')  # lims dataset만 저장됨
write.csv(bucket, 'buc.csv')
dir()

save(lims, file = 'lims')  # lims 데이터 셋 저장
save(bucket, file = 'bucket')  # bucket 데이터 셋 저장
save(pis_product, file = 'pis_product')  # pis_product 데이터 셋 저장

rm(list=ls())  #데이터셋 모두 삭제
dir()
load('lims') # 데이터 셋 불러오기 
load('bucket') # 데이터 셋 불러오기
load('pis_product') # 데이터 셋 불러오기



#날짜 데이터 변환하기 
str(pis_product$Date.Time)
pis_product$Date.Time = as.POSIXct(pis_product$Date.Time)
str(pis_product)



lims$Date.Time = as.POSIXct(lims$Date.Time)
str(lims)




# 날짜 형식 전처리 
head(bucket)
colnames(bucket)[1]
colnames(bucket)[1]=c("Date.Time")


bucket[,'Date.Time']=paste0(20,bucket$Date.Time)
bucket$Date.Time
bucket$Date.Time = as.POSIXct(bucket$Date.Time)
str(bucket)




#format을 사용해 날짜형식을 변환시킬때는 POSIXct 형식으로 변환되어 있어야 오류가 없음
pis_product[,'Date.Time']=pis_product %>% select(.,Date.Time) %>% format(.,"%Y-%m-%d")

pis_product[,1]=pis_product[,1] %>% format(.,"%Y-%m-%d") 

lims[,'Date.Time']=lims %>%select(.,Date.Time) %>% format(.,"%Y-%m-%d") 
bucket[,'Date.Time']=bucket %>%select(.,Date.Time) %>% format(.,"%Y-%m-%d") 

str(pis_product)
str(lims)
str(bucket)
#


#데이터 병합(merge방식)
bpa_dataset1 = merge(lims, pis_product,by='Date.Time')  #lims와 pis를 먼저 
head(bpa_dataset1,n=1)

bpa_dataset2 = merge(bpa_dataset1,bucket,by='Date.Time')
dim(bpa_dataset2);dim(lims);dim(bucket);dim(pis_product)

sum(is.na(bpa_dataset2))

bpa_dataset = na.omit(bpa_dataset2)


#데이터셋(이상치 제거전) 변수, 데이터 수 체크 
dim(bpa_dataset)


#y값(D50) 이상치 제거하기
colnames(bpa_dataset)
names(bpa_dataset)[2]
names(bpa_dataset)[2]=c("LT0.15")


boxplot(bpa_dataset$D50)
# abline(h=c(1224.411,1659.229),col="red",lty="dotted") 

boxplot(bpa_dataset$D50)$stats
# boxplot.stats(bpa_dataset$D50) 두가지 차이를 실행시켜서 확인해보세요. 



boxplot(bpa_dataset$D50)$stats[1] # Q1-IQR*1.5 
# 이상치 계산 : quantile(bpa_dataset$D50, 1/4) - IQR(bpa_dataset$D50)*1.5
boxplot(bpa_dataset$D50)$stats[5] # Q3+IQR*1.5
# 이상치 계산 : quantile(bpa_dataset$D50, 3/4) + IQR(bpa_dataset$D50)*1.5

bpa_set = bpa_dataset %>% filter(D50>boxplot(D50)$stats[1],D50<boxplot(D50)$stats[5]) %>% select(.,-Date.Time)

# bpa_set = bpa_dataset %>% filter(D50>1223.741,D50<1659.229) %>% select(.,-Date.Time) 

summary(bpa_set)
colnames(bpa_set)
dim(bpa_set)



# 최종 Dataset 저장 
save(bpa_set, file = 'bpa_set')  # 최종 데이터 set 저장
rm(list=ls()) # 모든 데이터 셋 삭제
load('bpa_set') # bpa_set 불러오기 

# write.csv(bpa_set, 'bpa_set.csv')



# 03. 데이터 탐색 -------------------------------------------------------------

#graph분석
pairs(bpa_set)

#boxplot(bpa_set)



# 04. 데이터 Set 구분하기 ------------------------------------------------------

#Data split

dim(bpa_set)
nrow(bpa_set)

set.seed(7279) 


train=sample(nrow(bpa_set),nrow(bpa_set)*0.7)
train

test=(1:2582)[-train]
test

length(train)
length(test)


#05. 모형 선정 -----------------------------------------------------------------

#분석실시(modeling) regression, rf

colnames(bpa_set)

lm.fit=lm(D50~.,data=bpa_set[train,-1])
summary(lm.fit)

step(lm.fit)

#최종 회귀식 m(formula = D50 ~ Feed_flow + Feed_Temp + Bucket.RPM_1
        #               + Bucket.RPM_2 + out_AirTemp + Prill.Tower_temp
        #               + Bucke.Hole.Size, data = bpa_set[train,-1])


colnames(bpa_set)
lm.fit_best=lm(D50 ~ Feed_flow + Feed_Temp + Bucket.RPM_1 + Bucket.RPM_2 + 
       + out_AirTemp + Prill.Tower_temp + Bucke.Hole.Size, data = bpa_set[train, -1])


#실제는 다중 공선성 체크하고, 변수 조정해줘야 함

summary(lm.fit_best) # Multiple R-sq 값 체크,  Estimate(부호 체크), *표시 체크 




library(randomForest) ; library(tree)
rf.fit=randomForest(D50~.,data=bpa_set[train,-1],importance=T)
rf.fit
# importance(rf.fit)
varImpPlot(rf.fit)



# 06. 모형 선택 --------------------------------------------------------------

# 상관관계 분석 후 제곱해서 계산, 
# but 실질적으로는 회귀 R-sq와, 랜덤포레스트  %var explained를 보고 판단하는 것이맞음

lm_obs = bpa_set[test,]$D50 #실제 관측값
lm_pred = predict(lm.fit_best,newdata=bpa_set[test,-1]) # 예측값 
rf_pred = predict(rf.fit,newdata=bpa_set[test,-1]) # 예측값 

#(cor(lm_pred,lm_obs))^2  #상관계수 제곱
#(cor(rf_pred,lm_obs))^2  #상관계수 제곱


library(DescTools)
MSE(lm_pred, lm_obs)
MSE(rf_pred, lm_obs)

RMSE(lm_pred, lm_obs) # 회귀식이 상대적으로 우수함
RMSE(rf_pred, lm_obs)

# library(Metrics) # 교육생 문의(6/25)
# bias(lm_pred, lm_obs)

# 07. 모형 최적화 --------------------------------------------------------------

# 모형 선택은 다중선형회귀를 선택함
#최적조건 구하기- 인자별 Range확인 (이상치 제거,  0이하 제거 )

print("Feature range")
for( i in 1:12){
  A = bpa_set %>% filter(bpa_set[,i]>0) %>% .[,i] 
  B = A[A>boxplot(A)$stats[1]&A<boxplot(A)$stats[5]] %>% range()
  print(data.frame(names=colnames(bpa_set)[i] ,lower=B[1],upper=B[2]))
}

bpa_set$Bucke.Hole.Size %>% table()  #Buckek.hole.size는 정수로, 범위 별도 체크 



summary(lm.fit_best) # 부호 다시 체크 

#08. 최적 모형 예측값 ----------------------------------------------------------

# 예측 값을 찾기 위해 회귀식 부호 방향을 체크하고, 그 값을 반영함
# 단, 실무적으로 각 변수의 설정값을 검토 하여 조정 가능함(비용, 안정성 측면 고려)

new=data.frame(Feed_flow=15.2507,         # 음
               Feed_Temp=163.8268,        # 음
               Bucket.RPM_1=83.1646,      # 음
               Bucket.RPM_2=93.2791,      # 음
               out_AirTemp=32.5472,       # 양
               Prill.Tower_temp=56.587,   # 양
               Bucke.Hole.Size=1.3,       # 양
               outAir.flow=806.5549)      # 양 (randomForest를 예측값을 위해 넣음)

new



#최적조건 구하기- 인자별 Range확인 (예측) 

predict(lm.fit_best,newdata=new)

# predict(rf.fit,newdata=new)









#참고) 다중공선성 고려했을때 ------------------

colnames(bpa_set)
lm.fit=lm(D50~.,data=bpa_set[train,-1])
summary(lm.fit)

library(car)
vif(lm.fit)

lm.fit = lm(D50 ~ Feed_flow + Feed_Temp + Bucket.RPM_1 + out_AirTemp 
            + Prill.Tower_temp + Bucke.Hole.Size, data = bpa_set[train, -1])

vif(lm.fit)
step(lm.fit)

#최종 회귀식 m(formula = D50 ~ Feed_flow + Feed_Temp + out_AirTemp 
#              + Prill.Tower_temp + Bucke.Hole.Size, data = bpa_set[train,-1])


colnames(bpa_set)
lm.fit_best=lm(D50 ~ Feed_flow + Feed_Temp + out_AirTemp 
                     + Prill.Tower_temp + Bucke.Hole.Size, data = bpa_set[train, -1])

summary(lm.fit_best) # Multiple R-sq 값 체크,  Estimate(부호 체크), *표시 체크 


library(randomForest) ; library(tree)
rf.fit=randomForest(D50~.,data=bpa_set[train,-1],importance=T)
rf.fit
importance(rf.fit)
varImpPlot(rf.fit)



# 최적 모형 선정
lm_obs = bpa_set[test,]$D50 #실제 관측값
lm_pred = predict(lm.fit_best,newdata=bpa_set[test,-1]) # 예측값 
rf_pred = predict(rf.fit,newdata=bpa_set[test,-1]) # 예측값 

(cor(lm_pred,lm_obs))^2  #상관계수 제곱
(cor(rf_pred,lm_obs))^2  #상관계수 제곱


library(DescTools)
MSE(lm_pred, lm_obs)
MSE(rf_pred, lm_obs)

RMSE(lm_pred, lm_obs) # 회귀식이 상대적으로 우수함
RMSE(rf_pred, lm_obs)


# 모형 최종 예측 값 확인 
print("Feature range")
for( i in 1:12){
  A = bpa_set %>% filter(bpa_set[,i]>0) %>% .[,i] 
  B = A[A>boxplot(A)$stats[1]&A<boxplot(A)$stats[5]] %>% range()
  print(data.frame(names=colnames(bpa_set)[i] ,lower=B[1],upper=B[2]))
}

bpa_set$Bucke.Hole.Size %>% table()  #Buckek.hole.size는 정수로, 범위 별도 체크 

summary(lm.fit_best) # 부호 다시 체크 



new=data.frame(Feed_flow=15.2507,         # 음
               Feed_Temp=163.8268,        # 음
               out_AirTemp=0.1058,        # 양
               Prill.Tower_temp=56.587,   # 양
               Bucke.Hole.Size=1.3)       # 양



predict(lm.fit_best,newdata=new)

# 전 _예제

# DX-LSS BB과정 --------------------------------------------------------------
# 작성자 : 백인엽P,  최종 수정일 : 20. 7. 22
# Text encoding : UTF-8

# 01. 세부 환경 설정 -----------------------------------------------------------
rm(list=ls())

#set Working directory 
getwd()
setwd("D:/#.Secure Work Folder/DX-LSS-Project/BB/전지")
dir()


# 02. 데이터 전처리 ------------------------------------------------------------

library(tidyr);library(dplyr)

# 데이터 불러오기 
# Data load
A=read.csv("200421_overlap_modelA.csv")
B=read.csv("200421_overlap_modelB.csv")
D=read.csv("200421_overlap_modelC.csv")


#Data pre-processing1 (평균)
A=(na.omit(A));B=na.omit(B);C=na.omit(C)  #model A데이터 빈칸을 NA로 인식관련 [,1:43]범위 설정 
dim(A);dim(B);dim(D)


#data 현수준 파악을 위한 데이터 저장
write.csv(A, 'A_Model.csv')


#데이터 특성 변환
str(B)
as.character(B$ 용접전압..1.) #용접전압..1.만 Factor로 되어 있어 변환 필요 
B$ 용접전압..1.=as.numeric(B$ 용접전압..1.)
str(B)


A=data.frame(y=A[,3], Model='A',A[1:2],
             overlap=apply(A[4:13],1,mean),
             voltage=apply(A[14:23],1,mean),
             current=apply(A[24:33],1,mean),
             resistor=apply(A[34:43],1,mean))

B=data.frame(y=B[,3], Model='B',B[1:2],
             overlap=apply(B[4:13],1,mean),
             voltage=apply(B[14:23],1,mean),
             current=apply(B[24:33],1,mean),
             resistor=apply(B[34:43],1,mean))

D=data.frame(y=D[,3], Model='C',D[1:2],
             overlap=apply(D[4:13],1,mean),
             voltage=apply(D[14:23],1,mean),
             current=apply(D[24:33],1,mean),
             resistor=apply(D[34:43],1,mean))

head(A);head(B);head(D)
str(A);str(B);str(D)


A$Model=factor(A$Model,levels=c('A','B','C'))  #A, B, C 레벨 설정
A$Model

B$Model=factor(B$Model,levels=c('A','B','C'))
B$Model

D$Model=factor(D$Model,levels=c('A','B','C'))
D$Model


#Data pre-processing3 (delete outlier )  

boxplot(A$y)
boxplot.stats(A$y)$stats[1]
boxplot.stats(A$y)$stats[5]

A=A %>% filter(y<boxplot.stats(A$y)$stats[5]) %>% filter(y>boxplot.stats(A$y)$stats[1])

boxplot(B$y)
boxplot.stats(B$y)
B=B %>% filter(y<boxplot.stats(B$y)$stats[5]) %>% filter(y>boxplot.stats(B$y)$stats[1])

boxplot(D$y)
boxplot.stats(D$y)
D=D %>% filter(y<boxplot.stats(D$y)$stats[5]) %>% filter(y>boxplot.stats(D$y)$stats[1])


#Data pre-processing4 (merge of A,B,C model )
ABD_total=rbind(A,B,D)
ABD=ABD_total %>% select(y,Model,overlap, voltage, current, resistor) #필요 변수 선택
str(ABD)

ABD$Model


# 03. 데이터 탐색 -------------------------------------------------------------
pairs(ABD)


# 04. 데이터 Set 구분하기 ------------------------------------------------------

#data_split (3 vs 7)
set.seed(7279)
train =sample(nrow(ABD), nrow(ABD)*0.7)
test= (1:270)[-train]



#05. 모형 선정 -----------------------------------------------------------------

#modeling-1 (linear model)
ABD %>% head(2)

lm_y=lm(y~.,data=ABD[train,])
lm_y
step(lm_y)

lm_y_best=lm(y ~ Model + overlap + current, data = ABD[train,])

#실제 다중공선성 체크 및 변수에 대한 실질적 조정이 필요함(실제는 voltage로 조정함)



#modeling-2 (randomForest)

library(randomForest)
library(tree)

rf_y=randomForest(y~.,data=ABD[train,],importance=T)
rf_y
importance(rf_y)
varImpPlot(rf_y)

# Tree그림 그리기
tree_y=tree(y~.,data=ABD[train,])
plot(tree_y);text(tree_y)

library(rpart)
tree_y2 = rpart(y~., data=ABD[train,])

par(mar=c(1,1,1,1), xpd = TRUE) 
plot(tree_y2) ; text(tree_y2, use.n = T)


# 06. 모형 선택 --------------------------------------------------------------
lm_obs = ABD$y[test]
lm_pred = predict(lm_y_best, newdata=ABD[test,])
rf_pred = predict(rf_y, newdata=ABD[test,])

(cor(lm_pred,lm_obs))^2  #상관계수 제곱
(cor(rf_pred,lm_obs))^2  #상관계수 제곱


library(DescTools)
MSE(lm_pred, lm_obs)
MSE(rf_pred, lm_obs)

RMSE(lm_pred, lm_obs) 
RMSE(rf_pred, lm_obs)



# 07. 모형 최적화 --------------------------------------------------------------

# 랜덤포레스트가 우수하나 큰 차이가 없어 lm으로 선정
# 최적조건 구하기- 인자별 Range확인

head(ABD,1)

print("Feature range")
for( i in 3:6){
  A = ABD %>% filter(ABD[,i]>0) %>% .[,i] 
  B = A[A>boxplot(A)$stats[1]&A<boxplot(A)$stats[5]] %>% range()
  print(data.frame(names=colnames(ABD)[i] ,lower=B[1],upper=B[2]))
}


summary(lm_y_best)



#08. 최적 모형 예측값 ----------------------------------------------------------

#최적조건 구하기- 인자별 Range확인(예측), 
# 단, 실무적으로 각 변수의 설정값을 검토 하여 조정 가능함(비용, 안정성 측면 고려)

new=data.frame(Model=factor('A',levels=c('A','B','C')),  #A모델(개선대상 A모델임)
               overlap= 2.47 ,    #양
               voltage= 3.15  ,   #양
               current= 1347.5 ,  #양   영향성은 낮지만, 부호방향으로 값 설정
               resistor= 23.2)    #양   영향성은 낮지만, RF관련 Tree기준으로 입력 


predict(lm_y_best,newdata=new)
predict(rf_y,newdata=new)



# housing 예제

# ● 추가 연습 데이터 housing --------------------------------------------------

setwd("D:/#.Secure Work Folder/DX-LSS-Project/UCI databases")

bh = read.table("housing.data")
# 1. CRIM      per capita crime rate by town
# 2. ZN        proportion of residential land zoned for lots over 25,000 sq.ft.
# 3. INDUS     proportion of non-retail business acres per town
# 4. CHAS      Charles River dummy variable 
#    (= 1 if tract bounds river; 0 otherwise)
# 5. NOX       nitric oxides concentration (parts per 10 million)
# 6. RM        average number of rooms per dwelling
# 7. AGE       proportion of owner-occupied units built prior to 1940
# 8. DIS       weighted distances to five Boston employment centres
# 9. RAD       index of accessibility to radial highways
# 10. TAX      full-value property-tax rate per $10,000
# 11. PTRATIO  pupil-teacher ratio by town
# 12. B        1000(Bk - 0.63)^2 where Bk is the proportion of blacks by town
# 13. LSTAT    % lower status of the population
# 14. MEDV     Median value of owner-occupied homes in $1000's

colnames(bh) = c("crim", "zn", "indus", "chas", "nox", "rm", "age", "dis", "rad", "tax", "ptratio", "b", "lstat", "medv")
colnames(bh)

library(ggplot2)
ggplot(bh, aes(rm,lstat, color = medv))+geom_point(size=5, alpha=0.5)
ggplot(bh, aes(nox,crim, color = medv))+geom_point(size=5, alpha=0.5)

ggplot(bh, aes(rm,medv))+geom_point(size=5, alpha=0.5)

bh$Q = ifelse(bh$medv > 40, "40이상", "40이하")
ggplot(bh, aes(rm,medv))+geom_boxplot(aes(colour=Q), alpha = 0.4)

ggplot(bh, aes(rm,lstat))+
  geom_point(aes(colour=Q), alpha = 0.4)

ggplot(bh, aes(rm,dis))+
  geom_point(aes(colour=Q), alpha = 0.4)

ggplot(bh, aes(rm,nox))+
  geom_point(aes(colour=Q), alpha = 0.4)

ggplot(bh, aes(rm,crim))+
  geom_point(aes(colour=Q), alpha = 0.4)

ggplot(bh, aes(rm,ptratio))+
  geom_point(aes(colour=Q), alpha = 0.4)

ggplot(bh, aes(rm,lstat))+
  geom_boxplot(aes(colour=Q), alpha = 0.4)

#pairs(bh)
#cor(bh)


#다중선형회귀분석


lm.bh = lm(medv~.,data=bh)
summary(lm.bh)
library(car)

vif(lm.bh)
step(lm.bh)


lm.bh.best = lm(medv ~ crim + zn + chas + nox + rm + dis + rad + 
                  tax + ptratio + b + lstat, data = bh)
summary(lm.bh.best)
plot(lm.bh.best)

# 책에 나온 대로 수정
lm.bh.best2 = lm(medv ~. ^2, data = bh) 
summary(lm.bh.best)
plot(lm.bh.best)


# stepAIC를 통해서 보다 많은 경우의 수를 평가 해당 과정에 대해서 Study필요
# MBB 역량 강화에서 공유하기 좋은 주제 이며, 과정에 대한 학습이 필요함. (20.7.17)
data_step <- stepAIC(data_lm_full, 
                     scope = list(upper = ~.^2, lower = ~1))

summary(data_step)
length(coef(data_step))

# 더 나은 분석을 위해서 추가 머신 러닝에 대해서 진행 필요함
# 추가 과정은 LASSO, Ridge 방법을 통해서 추가 변수 축소 과정이 진행됨






library(randomForest)
rf.bh = randomForest(medv~., data=bh, importance = TRUE)
importance(rf.bh)
varImpPlot(rf.bh)
rf.bh



y_obs = bh$medv
y_hat_rf = predict(rf.bh, data=bh)
y_hat_lm = predict(lm.bh.best, data=bh)

library(DescTools)
RMSE(y_hat_lm, y_obs)
RMSE(y_hat_rf, y_obs)


print("Feature range")
data = bh
colnames(data)
for( i in 1:length(data)){
  A = data %>% filter(data[,i]>0) %>% .[,i] 
  B = A[A>boxplot(A)$stats[1]&A<boxplot(A)$stats[5]] %>% range()
  print(data.frame(names=colnames(data)[i] ,lower=B[1],upper=B[2]))
}

table(data$chas)

library(rpart)
tr.bh = rpart(bh$medv~., data=bh)
plot(tr.bh) ; text(tr.bh)

library(party)
ctr.bh = ctree(bh$medv~., data=bh)
plot(ctr.bh) ; text(ctr.bh)

colnames(bh)
newdt = data.frame(crim = 0.00906,   #음
                   zn = 95 ,  #양
                   chas = 1,  #양
                   nox = 0.389, #음
                   rm = 7.686, #양
                   dis = 1.137, #음
                   rad = 8, #양
                   tax = 188, #음
                   ptratio = 14.4, #음 
                   b = 396.42, #양
                   lstat = 1.91,#음
                   age = 77.5, # median 랜덤포레스트용
                   crim = 8.79212, # tree 기준 램덤포레스트용
                   indus = 9.69 # median 랜덤포레스트용
)

median(bh$age)
median(bh$crim)
median(bh$indus)


predict(lm.bh.best, newdata = newdt)
predict(rf.bh, newdata = newdt)


# 
